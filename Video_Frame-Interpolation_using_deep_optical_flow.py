# -*- coding: utf-8 -*-
"""DVPA_Assignment_1_Optical_flow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ka2GySMGJn_PA_ErVXXzAqBwWkKXs0st
"""

!git clone https://github.com/princeton-vl/RAFT.git

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import os
import sys
import numpy as np
import cv2
import pandas as pd

import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.transforms as T
import matplotlib.pyplot as plt
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
# %matplotlib inline

sys.path.append('RAFT/core')

# Commented out IPython magic to ensure Python compatibility.
# %cd RAFT
!./download_models.sh
# !python demo.py --model=models/raft-things.pth --path=demo-frames
# %cd ..

from collections import OrderedDict
from raft import RAFT
from utils import flow_viz
from utils.utils import InputPadder



def process_img(img, device):
    return torch.from_numpy(img).permute(2, 0, 1).float()[None].to(device)


def load_model(weights_path, args):
    model = RAFT(args)
    pretrained_weights = torch.load(weights_path, map_location=torch.device("cpu"))
    model = torch.nn.DataParallel(model)
    model.load_state_dict(pretrained_weights)
    model.to("cuda")
    return model


def inference(model, frame1, frame2, device, pad_mode='sintel',
              iters=12, flow_init=None, upsample=True, test_mode=True):

    model.eval()
    with torch.no_grad():
        # preprocess
        frame1 = process_img(frame1, device)
        frame2 = process_img(frame2, device)

        padder = InputPadder(frame1.shape, mode=pad_mode)
        frame1, frame2 = padder.pad(frame1, frame2)

        # predict flow
        if test_mode:
          flow_low, flow_up = model(frame1,
                                    frame2,
                                    iters=iters,
                                    flow_init=flow_init,
                                    upsample=upsample,
                                    test_mode=test_mode)



          return flow_low, flow_up

        else:
            flow_iters = model(frame1,
                               frame2,
                               iters=iters,
                               flow_init=flow_init,
                               upsample=upsample,
                               test_mode=test_mode)

            return flow_iters


def get_viz(flo):
    flo = flo[0].permute(1,2,0).cpu().numpy()
    return flow_viz.flow_to_image(flo)

# sketchy class to pass to RAFT
class Args():
  def __init__(self, model='', path='', small=False, mixed_precision=True, alternate_corr=False):
    self.model = model
    self.path = path
    self.small = small
    self.mixed_precision = mixed_precision
    self.alternate_corr = alternate_corr

  """ Sketchy hack to pretend to iterate through the class objects """
  def __iter__(self):
    return self

  def __next__(self):
    raise StopIteration

model = load_model("RAFT/models/raft-sintel.pth", args=Args())

def warp_image(image_tensor, flow_tensor):
    # Convert the image tensor to a NumPy array
    image_np = image_tensor.squeeze(0).permute(1, 2, 0).cpu().numpy()  # Shape: (384, 504, 3)
    flow_np = flow_tensor.squeeze(0).permute(1, 2, 0).cpu().numpy()  # Shape: (384, 504, 2)

    h, w, _ = image_np.shape

    # Create a meshgrid of x and y coordinates
    x_coords, y_coords = np.meshgrid(np.arange(w), np.arange(h))

    # Create the flow map by adding the flow to the original coordinates
    flow_map = np.stack((x_coords, y_coords), axis=-1).astype(np.float32) + flow_np  # Shape: (384, 504, 2)

    # Separate the channels and remap each one
    remapped_channels = []
    for i in range(3):  # Assuming 3 color channels (RGB)
        remapped = cv2.remap(image_np[:, :, i], flow_map, None, cv2.INTER_LINEAR)
        remapped_channels.append(remapped)

    # Stack the channels back together
    remapped_image_np = np.stack(remapped_channels, axis=-1)  # Shape: (384, 504, 3)

    # Convert the remapped image back to a tensor
    remapped_image_tensor = torch.from_numpy(remapped_image_np).permute(2, 0, 1).unsqueeze(0).to(image_tensor.device)  # Shape: (1, 3, 384, 504)

    return remapped_image_tensor


def interpolate_frame(img1, img2, forward_flow, backward_flow):
    warped_img1 = warp_image(img1, forward_flow / 2)
    warped_img2 = warp_image(img2, -backward_flow / 2)
    interpolated_frame = 0.5 * warped_img1 + 0.5 * warped_img2
    return interpolated_frame

def visualize_images(ground_truth, interpolated, i):
    # Convert tensors to NumPy arrays and move the channels last for display (C, H, W) -> (H, W, C)
    gt_image_np = ground_truth.squeeze(0).permute(1, 2, 0).cpu().numpy()
    interpolated_image_np = interpolated.squeeze(0).permute(1, 2, 0).cpu().numpy()

    # Normalize to [0, 1] if necessary (assuming images are in [0, 255])
    gt_image_np = gt_image_np / 255.0 if gt_image_np.max() > 1 else gt_image_np
    interpolated_image_np = interpolated_image_np / 255.0 if interpolated_image_np.max() > 1 else interpolated_image_np

    # Plot the images
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.imshow(gt_image_np)
    plt.title(f"Ground Truth of frame {i}")
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(interpolated_image_np)
    plt.title(f"Interpolated Frame of frame {i}")
    plt.axis('off')

    plt.show()

device='cuda'
image_path_0 = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8/image017.png'
frame_0 = cv2.imread(image_path_0, cv2.IMREAD_COLOR)
image_path_2 = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8/image018.png'
frame_2 = cv2.imread(image_path_2, cv2.IMREAD_COLOR)
image_path_1 = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8/image019.png'
frame_1 = cv2.imread(image_path_1, cv2.IMREAD_COLOR)
#plt.imshow(frame_2)
frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)
plt.imshow(frame2)

flow_iters = inference(model, frame0, frame2, device='cuda', iters=20, test_mode=False)

f, (ax0, ax1) = plt.subplots(1,2, figsize=(20,10))

ax0.imshow(get_viz(flow_iters[0]))
ax0.set_title('first flow iteration')
ax1.imshow(get_viz(flow_iters[-1]))
ax1.set_title('final flow iteration');

flow_iters_backwd = inference(model, frame2, frame0, device='cuda', iters=20, test_mode=False)

f, (ax0, ax1) = plt.subplots(1,2, figsize=(20,10))

ax0.imshow(get_viz(flow_iters_backwd[0]))
ax0.set_title('first flow iteration')
ax1.imshow(get_viz(flow_iters_backwd[-1]))
ax1.set_title('final flow iteration');

frame0 = process_img(frame0, device)
frame2 = process_img(frame2, device)
frame1 = process_img(frame1, device)
padder = InputPadder(frame0.shape, mode='sintel')
frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])

visualize_images(frame1, frame1_int,1)

"""**EXPERIMENT 1**

# Flower image Folder #
"""

def conversion(ground_truth):
    gt_image_np = ground_truth.squeeze(0).permute(1, 2, 0).cpu().numpy()
    #interpolated_image_np = interpolated.squeeze(0).permute(1, 2, 0).cpu().numpy()
    if gt_image_np.max() <= 1:
        gt_image_np = (gt_image_np * 255).astype('uint8')
    return gt_image_np

device = 'cuda'

# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8'
for i in range(0, 32, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_COLOR)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_COLOR)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_COLOR)
   frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
   frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
   frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

   flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
   flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)

   frame0 = process_img(frame0, device)
   frame2 = process_img(frame2, device)
   frame1 = process_img(frame1, device)
   padder = InputPadder(frame0.shape, mode='sintel')
   frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

   frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame1, frame1_int,i+1)
   gt_np, int0_np = conversion(frame1), conversion(frame1_int)
   psnr_value = psnr(gt_np, int0_np, data_range=255)
   ssim_value = ssim(gt_np, int0_np, multichannel=True, win_size=381, data_range=255, channel_axis=2)
   print("PSNR is", psnr_value, "and SSIM is", ssim_value)

"""#Fern Image folder#"""

device = 'cuda'

# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8'
for i in range(0, 18, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_COLOR)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_COLOR)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_COLOR)
   frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
   frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
   frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

   flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
   flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)

   frame0 = process_img(frame0, device)
   frame2 = process_img(frame2, device)
   frame1 = process_img(frame1, device)
   padder = InputPadder(frame0.shape, mode='sintel')
   frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

   frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame1, frame1_int,i+1)
   gt_np, int0_np = conversion(frame1), conversion(frame1_int)
   psnr_value = psnr(gt_np, int0_np, data_range=255)
   ssim_value = ssim(gt_np, int0_np, multichannel=True, win_size=381, data_range=255, channel_axis=2)
   print("PSNR is", psnr_value, "and SSIM is", ssim_value)

"""**EXPERIMENT 2**"""

!apt-get install ffmpeg

def interpolate_frame(img1, img2, forward_flow, backward_flow, t):
    warped_img1 = warp_image(img1, forward_flow * t)
    warped_img2 = warp_image(img2, -backward_flow * (1-t))
    interpolated_frame = (1-t) * warped_img1 + t * warped_img2
    return interpolated_frame

import matplotlib.pyplot as plt

import os


def visualize_int_frames(interpolated1, interpolated2, interpolated3, i, output_folder):
    k=i*4
    k1=k+1
    k2=k+2
    k3=k+3
    # Ensure the output folder exists
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    # Convert tensors to NumPy arrays and move the channels last for display (C, H, W) -> (H, W, C)
    interpolated_image_np_1 = interpolated1.squeeze(0).permute(1, 2, 0).cpu().numpy()
    interpolated_image_np_2 = interpolated2.squeeze(0).permute(1, 2, 0).cpu().numpy()
    interpolated_image_np_3 = interpolated3.squeeze(0).permute(1, 2, 0).cpu().numpy()

    # Normalize to [0, 1] if necessary (assuming images are in [0, 255])
    interpolated_image_np_1 = interpolated_image_np_1 / 255.0 if interpolated_image_np_1.max() > 1 else interpolated_image_np_1
    interpolated_image_np_2 = interpolated_image_np_2 / 255.0 if interpolated_image_np_2.max() > 1 else interpolated_image_np_2
    interpolated_image_np_3 = interpolated_image_np_3 / 255.0 if interpolated_image_np_3.max() > 1 else interpolated_image_np_3

    # Plot the images
    plt.figure(figsize=(15, 5))
    plt.subplot(1, 3, 1)
    plt.imshow(interpolated_image_np_1)
    plt.title(f"Interpolated Frame {i} at t=1/4")

    plt.subplot(1, 3, 2)
    plt.imshow(interpolated_image_np_2)
    plt.title(f"Interpolated Frame {i} at t=2/4")

    plt.subplot(1, 3, 3)
    plt.imshow(interpolated_image_np_3)
    plt.title(f"Interpolated Frame {i} at t=3/4")

    plt.show()

    # Save the interpolated images in the given folder
    plt.imsave(os.path.join(output_folder, f'image{k1:03d}.png'), interpolated_image_np_1)
    plt.imsave(os.path.join(output_folder, f'image{k2:03d}.png'), interpolated_image_np_2)
    plt.imsave(os.path.join(output_folder, f'image{k3:03d}.png'), interpolated_image_np_3)

import os
from PIL import Image


input_folder = "/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8"
output_folder = "/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/HS_flower"


if not os.path.exists(output_folder):
    os.makedirs(output_folder)

for filename in os.listdir(input_folder):
    if filename.startswith("image") and filename.endswith(".png"):
        # Extract the number from the filename
        num_part = int(filename[5:8])

        # Multiply the number by 4
        new_num_part = num_part * 4
        new_filename = f"image{new_num_part:03d}.png"

        # Open the image and convert it to grayscale
        img_path = os.path.join(input_folder, filename)
        img = Image.open(img_path).convert('L')


        new_img_path = os.path.join(output_folder, new_filename)
        img.save(new_img_path)

"""# Flower"""

out_path="/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/colorflower"
folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8'
for i in range(0, 33, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  #
   #image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_COLOR)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_COLOR)
   #frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
   frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
   #frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
   frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

   flow_iters = inference(model, frame0, frame1, device=device, iters=20, test_mode=False)
   flow_iters_backwd = inference(model, frame1, frame0, device=device, iters=20, test_mode=False)

   frame0 = process_img(frame0, device)
  # frame2 = process_img(frame2, device)
   frame1 = process_img(frame1, device)
   padder = InputPadder(frame0.shape, mode='sintel')
   frame0, frame1 = padder.pad(frame0, frame1)

   frame_t1 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=1/4)
   frame_t2 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=2/4)
   frame_t3 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=3/4)
   print(i,"frame")
   visualize_int_frames(frame_t1, frame_t2, frame_t3,i,out_path)

"""# Ferm"""

out_path="/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/colorfern"
folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8'
for i in range(0, 18, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  #
   #image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_COLOR)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_COLOR)
   #frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
   frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
   #frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
   frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

   flow_iters = inference(model, frame0, frame1, device=device, iters=20, test_mode=False)
   flow_iters_backwd = inference(model, frame1, frame0, device=device, iters=20, test_mode=False)

   frame0 = process_img(frame0, device)
  # frame2 = process_img(frame2, device)
   frame1 = process_img(frame1, device)
   padder = InputPadder(frame0.shape, mode='sintel')
   frame0, frame1 = padder.pad(frame0, frame1)

   frame_t1 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=1/4)
   frame_t2 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=2/4)
   frame_t3 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=3/4)
   print(i,"frame")
   visualize_int_frames(frame_t1, frame_t2, frame_t3,i,out_path)

!ffmpeg -framerate 30 -i /content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/colorflower/image%03d.png -c:v libx264 -pix_fmt yuv420p flower_video.mp4

!ffmpeg -framerate 30 -i /content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/colorfern/image%03d.png -c:v libx264 -pix_fmt yuv420p fern_video.mp4

!ffmpeg -framerate 7 -i /content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8/image%03d.png -c:v libx264 -pix_fmt yuv420p output_video_flower_original.mp4

!ffmpeg -framerate 7 -i /content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8/image%03d.png -c:v libx264 -pix_fmt yuv420p output_video_fern_original.mp4

"""# Horn Schunk"""

image_path_1 = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8/image000.png'
main_image_1 = cv2.imread(image_path_1, cv2.IMREAD_GRAYSCALE)
print(main_image_1.shape)
image_path_2 = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8/image002.png'
main_image_2 = cv2.imread(image_path_2, cv2.IMREAD_GRAYSCALE)
plt.imshow(main_image_1, cmap = 'gray')

!pip install --upgrade scikit-image

!pip install pyoptflow

from skimage.metrics import peak_signal_noise_ratio, structural_similarity
import numpy as np
from skimage import color
from skimage.restoration import denoise_bilateral
from skimage import filters
from pyoptflow import HornSchunck

# function for getting downsampled images and creatin Gaussian pyramids
def create_gaussian_pyramid(img, num_levels):
    pyramid = [img]
    for i in range(1, num_levels):
        # Downsample the image
        img = cv2.pyrDown(img)
        pyramid.append(img)
    return pyramid

def warp_image(image, flow):
    # h , w = flow.shape[:2]
    h, w = image.shape
    # getting the pixel coordinates, from 0 to h-1 and 0 to w-1
    x_coords, y_coords = np.meshgrid(np.arange(w), np.arange(h))
    # meshgrid returns two 2-D arrays that cntains x co-ords and y co-ords for all the locations. Flow is 3-D, 32-D arrays of (a, b) stacked. We add to get f(x+a, y+b)
    flow_map = np.stack((x_coords, y_coords), axis=-1).astype(np.float32) + flow
    # Interpolate: Linear Interpolation
    remapped = cv2.remap(image, flow_map, None, cv2.INTER_LINEAR)
    return remapped

def flow_HS(img1, img2, num_scales, alpha=1.5, num_iter=200):

    # downsampling LK using pyrlk in 3 level
    img1_pyramid = create_gaussian_pyramid(img1, num_scales)
    img2_pyramid = create_gaussian_pyramid(img2, num_scales)

    # vertical and horizontal flow initialisation
    h, w = img1_pyramid[-1].shape[:2]
    flow_u = np.zeros((h, w), dtype=np.float32)
    flow_v = np.zeros((h, w), dtype=np.float32)

    # multiscale flow calculation
    for level in reversed(range(num_scales)):
        if level != num_scales - 1:
           # alpha=alpha/(level+1)
            #num_iter=num_iter*(level+1)
            # Upscale the flow after multiplying by two for all layers starting from (n-1)
            flow_u = cv2.resize(flow_u, (img1_pyramid[level].shape[1], img1_pyramid[level].shape[0])) * 2
            flow_v = cv2.resize(flow_v, (img1_pyramid[level].shape[1], img1_pyramid[level].shape[0])) * 2
        next_flow_u, next_flow_v = HornSchunck(img1_pyramid[level], img2_pyramid[level], alpha=a, Niter=n)
        flow_u += next_flow_u
        flow_v += next_flow_v

    # stack the final flow vectors
    flow = np.stack((flow_u, flow_v), axis=-1)
    return flow


def interpolate_frame(img1, img2, forward_flow, backward_flow):
    # fowarad warping
    warped_img1 = warp_image(img1, forward_flow / 2)
    # backward warping
    warped_img2 = warp_image(img2, -backward_flow / 2)
    # average image of two frames
    interpolated_frame = 0.5 * warped_img1 + 0.5 * warped_img2
    return interpolated_frame.astype(np.uint8)

def calculate_metrics(gt, new_frame):
    psnr = peak_signal_noise_ratio(gt, new_frame)
    ssim = structural_similarity(gt, new_frame, multichannel=True)
    return psnr, ssim
s1,s2,s3=3,2,1

def visualize_images(image1, image2, i):
    # Create a 1x2 subplot
    fig, axs = plt.subplots(1, 2, figsize=(10, 5))

    # Display the first image (GT) in grayscale
    axs[0].imshow(image1, cmap='gray')
    axs[0].axis('off')  # Hide axis
    axs[0].set_title(f'Frame {i+1} GT')

    # Display the second image (Interpolated) in grayscale
    axs[1].imshow(image2, cmap='gray')
    axs[1].axis('off')  # Hide axis
    axs[1].set_title(f'Interpolated Frame {i+1}')

    # Show the images
    plt.tight_layout()
    plt.show()

"""# EXPERIMENT 1

# Flower scale 1
"""

num_scales =s1
a=1
n=1
# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8'
for i in range(0, 32, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  #  frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
  #  frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
  #  frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

  #  flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
  #  flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)


   forward_flow = flow_HS(frame_0, frame_2, num_scales)
   backward_flow = flow_HS(frame_2, frame_0, num_scales)
   interpolated_frame = interpolate_frame(frame_0, frame_2, forward_flow, backward_flow)
  #  frame0 = process_img(frame0, device)
  #  frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

  #  frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame_1, interpolated_frame,i)
   psnr, ssim = calculate_metrics(frame_1, interpolated_frame)
   print('PSNR Between GT and obtained image:', psnr,'SSIM Between GT and obtained image:', ssim)

"""# Flower scale 2"""

num_scales =s2

# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8'
for i in range(0, 32, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  #  frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
  #  frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
  #  frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

  #  flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
  #  flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)


   forward_flow = flow_HS(frame_0, frame_2, num_scales)
   backward_flow = flow_HS(frame_2, frame_0, num_scales)
   interpolated_frame = interpolate_frame(frame_0, frame_2, forward_flow, backward_flow)
  #  frame0 = process_img(frame0, device)
  #  frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

  #  frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame_1, interpolated_frame,i)
   psnr, ssim = calculate_metrics(frame_1, interpolated_frame)
   print('PSNR Between GT and obtained image:', psnr,'SSIM Between GT and obtained image:', ssim)

"""# Flower Scale 3"""

num_scales =s3

# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8'
for i in range(0, 32, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  #  frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
  #  frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
  #  frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

  #  flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
  #  flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)


   forward_flow = flow_HS(frame_0, frame_2, num_scales)
   backward_flow = flow_HS(frame_2, frame_0, num_scales)
   interpolated_frame = interpolate_frame(frame_0, frame_2, forward_flow, backward_flow)
  #  frame0 = process_img(frame0, device)
  #  frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

  #  frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame_1, interpolated_frame,i)
   psnr, ssim = calculate_metrics(frame_1, interpolated_frame)
   print('PSNR Between GT and obtained image:', psnr,'SSIM Between GT and obtained image:', ssim)

"""# Fern Scale 1"""

num_scales =s1

# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8'
for i in range(0, 18, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  #  frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
  #  frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
  #  frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

  #  flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
  #  flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)


   forward_flow = flow_HS(frame_0, frame_2, num_scales)
   backward_flow = flow_HS(frame_2, frame_0, num_scales)
   interpolated_frame = interpolate_frame(frame_0, frame_2, forward_flow, backward_flow)
  #  frame0 = process_img(frame0, device)
  #  frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

  #  frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame_1, interpolated_frame,i)
   psnr, ssim = calculate_metrics(frame_1, interpolated_frame)
   print('PSNR Between GT and obtained image:', psnr,'SSIM Between GT and obtained image:', ssim)

"""# Fern Scale 2"""

num_scales =s2

# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8'
for i in range(0, 18, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  #  frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
  #  frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
  #  frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

  #  flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
  #  flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)


   forward_flow = flow_HS(frame_0, frame_2, num_scales)
   backward_flow = flow_HS(frame_2, frame_0, num_scales)
   interpolated_frame = interpolate_frame(frame_0, frame_2, forward_flow, backward_flow)
  #  frame0 = process_img(frame0, device)
  #  frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

  #  frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame_1, interpolated_frame,i)
   psnr, ssim = calculate_metrics(frame_1, interpolated_frame)
   print('PSNR Between GT and obtained image:', psnr,'SSIM Between GT and obtained image:', ssim)

"""# Fern Scale 3"""

num_scales =s3

# Function to load and preprocess an image

folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8'
for i in range(0, 18, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  # 2nd image (GT)
   image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  #  frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
  #  frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
  #  frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

  #  flow_iters = inference(model, frame0, frame2, device=device, iters=20, test_mode=False)
  #  flow_iters_backwd = inference(model, frame2, frame0, device=device, iters=20, test_mode=False)


   forward_flow = flow_HS(frame_0, frame_2, num_scales)
   backward_flow = flow_HS(frame_2, frame_0, num_scales)
   interpolated_frame = interpolate_frame(frame_0, frame_2, forward_flow, backward_flow)
  #  frame0 = process_img(frame0, device)
  #  frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame2, frame1 = padder.pad(frame0, frame2, frame1)

  #  frame1_int = interpolate_frame(frame0, frame2, flow_iters[-1], flow_iters_backwd[-1])
   print(i+1,"frame")
   visualize_images(frame_1, interpolated_frame,i)
   psnr, ssim = calculate_metrics(frame_1, interpolated_frame)
   print('PSNR Between GT and obtained image:', psnr,'SSIM Between GT and obtained image:', ssim)

"""#Experiment2"""

def interpolate_frame(img1, img2, forward_flow, backward_flow, t):
    warped_img1 = warp_image(img1, forward_flow * t)
    warped_img2 = warp_image(img2, -backward_flow * (1-t))
    interpolated_frame = (1-t) * warped_img1 + t * warped_img2
    return interpolated_frame.astype(np.uint8)

from skimage.metrics import peak_signal_noise_ratio, structural_similarity
import numpy as np
from skimage import color
from skimage.restoration import denoise_bilateral
from skimage import filters
from pyoptflow import HornSchunck

# function for getting downsampled images and creatin Gaussian pyramids
def create_gaussian_pyramid(img, num_levels):
    pyramid = [img]
    for i in range(1, num_levels):
        # Downsample the image
        img = cv2.pyrDown(img)
        pyramid.append(img)
    return pyramid

def warp_image(image, flow):
    # h , w = flow.shape[:2]
    h, w = image.shape
    # getting the pixel coordinates, from 0 to h-1 and 0 to w-1
    x_coords, y_coords = np.meshgrid(np.arange(w), np.arange(h))
    # meshgrid returns two 2-D arrays that cntains x co-ords and y co-ords for all the locations. Flow is 3-D, 32-D arrays of (a, b) stacked. We add to get f(x+a, y+b)
    flow_map = np.stack((x_coords, y_coords), axis=-1).astype(np.float32) + flow
    # Interpolate: Linear Interpolation
    remapped = cv2.remap(image, flow_map, None, cv2.INTER_LINEAR)
    return remapped

def flow_HS(img1, img2, num_scales, alpha=15, num_iter=100):

    # downsampling LK using pyrlk in 3 level
    img1_pyramid = create_gaussian_pyramid(img1, num_scales)
    img2_pyramid = create_gaussian_pyramid(img2, num_scales)

    # vertical and horizontal flow initialisation
    h, w = img1_pyramid[-1].shape[:2]
    flow_u = np.zeros((h, w), dtype=np.float32)
    flow_v = np.zeros((h, w), dtype=np.float32)

    # multiscale flow calculation
    for level in reversed(range(num_scales)):
        if level != num_scales - 1:
           # alpha=alpha/(level+1)
            #num_iter=num_iter*(level+1)
            # Upscale the flow after multiplying by two for all layers starting from (n-1)
            flow_u = cv2.resize(flow_u, (img1_pyramid[level].shape[1], img1_pyramid[level].shape[0])) * 2
            flow_v = cv2.resize(flow_v, (img1_pyramid[level].shape[1], img1_pyramid[level].shape[0])) * 2
        next_flow_u, next_flow_v = HornSchunck(img1_pyramid[level], img2_pyramid[level], alpha=a, Niter=n)
        flow_u += next_flow_u
        flow_v += next_flow_v

    # stack the final flow vectors
    flow = np.stack((flow_u, flow_v), axis=-1)
    return flow



def calculate_metrics(gt, new_frame):
    psnr = peak_signal_noise_ratio(gt, new_frame)
    ssim = structural_similarity(gt, new_frame, multichannel=True)
    return psnr, ssim

import os
import numpy as np
import matplotlib.pyplot as plt

def visualize_int_frames(interpolated1, interpolated2, interpolated3, i, output_folder):
    k = i * 4
    k1 = k + 1
    k2 = k + 2
    k3 = k + 3

    # Ensure the output folder exists
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    # Since the input images are already NumPy arrays and in grayscale, we don't need to permute or normalize.
    interpolated_image_np_1 = interpolated1  # Grayscale images, already NumPy arrays
    interpolated_image_np_2 = interpolated2
    interpolated_image_np_3 = interpolated3

    # Plot the images (Grayscale doesn't need RGB handling)
    plt.figure(figsize=(15, 5))

    plt.subplot(1, 3, 1)
    plt.imshow(interpolated_image_np_1, cmap='gray')
    plt.title(f"Interpolated Frame {i} at t=1/4")

    plt.subplot(1, 3, 2)
    plt.imshow(interpolated_image_np_2, cmap='gray')
    plt.title(f"Interpolated Frame {i} at t=2/4")

    plt.subplot(1, 3, 3)
    plt.imshow(interpolated_image_np_3, cmap='gray')
    plt.title(f"Interpolated Frame {i} at t=3/4")

    plt.show()

    # Save the interpolated images in the given folder
    plt.imsave(os.path.join(output_folder, f'image{k1:03d}.png'), interpolated_image_np_1, cmap='gray')
    plt.imsave(os.path.join(output_folder, f'image{k2:03d}.png'), interpolated_image_np_2, cmap='gray')
    plt.imsave(os.path.join(output_folder, f'image{k3:03d}.png'), interpolated_image_np_3, cmap='gray')

"""#FERN"""

out_path="/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/HS_fern"
folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/fern/images_8'
for i in range(0, 18, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  #
   #image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   #frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  # frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
   #frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
   #frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

   forward_flow = flow_HS(frame_0, frame_1, num_scales)
   backward_flow = flow_HS(frame_1, frame_0, num_scales)
   it_f1 = interpolate_frame(frame_0, frame_1, forward_flow, backward_flow,t=1/4)
   it_f2 = interpolate_frame(frame_0, frame_1, forward_flow, backward_flow,t=2/4)
   it_f3 = interpolate_frame(frame_0, frame_1, forward_flow, backward_flow,t=3/4)
   #frame0 = process_img(frame0, device)
  # frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame1 = padder.pad(frame0, frame1)

  #  frame_t1 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=1/4)
  #  frame_t2 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=2/4)
  #  frame_t3 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=3/4)
   print(i,"frame")
   visualize_int_frames(it_f1,it_f2, it_f3,i,out_path)

"""# FLOWER"""

out_path="/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/HS_flower"
folder_path = '/content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/fern_and_flower_llff/flower/images_8'
for i in range(0, 32, 1):
   image0_path = os.path.join(folder_path, f'image{str(i).zfill(3)}.png')  # 1st image
   image1_path = os.path.join(folder_path, f'image{str(i+1).zfill(3)}.png')  #
   #image2_path = os.path.join(folder_path, f'image{str(i+2).zfill(3)}.png')  # 3rd image
  #  print(image0_path, image1_path, image2_path)
  #  print("hi")
   frame_0 = cv2.imread(image0_path, cv2.IMREAD_GRAYSCALE)
   frame_1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
   #frame_2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)
  # frame0 = cv2.cvtColor(frame_0, cv2.COLOR_BGR2RGB)
   #frame2 = cv2.cvtColor(frame_2, cv2.COLOR_BGR2RGB)
   #frame1 = cv2.cvtColor(frame_1, cv2.COLOR_BGR2RGB)

   forward_flow = flow_HS(frame_0, frame_1, num_scales)
   backward_flow = flow_HS(frame_1, frame_0, num_scales)
   it_f1 = interpolate_frame(frame_0, frame_1, forward_flow, backward_flow,t=1/4)
   it_f2 = interpolate_frame(frame_0, frame_1, forward_flow, backward_flow,t=2/4)
   it_f3 = interpolate_frame(frame_0, frame_1, forward_flow, backward_flow,t=3/4)
   #frame0 = process_img(frame0, device)
  # frame2 = process_img(frame2, device)
  #  frame1 = process_img(frame1, device)
  #  padder = InputPadder(frame0.shape, mode='sintel')
  #  frame0, frame1 = padder.pad(frame0, frame1)

  #  frame_t1 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=1/4)
  #  frame_t2 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=2/4)
  #  frame_t3 = interpolate_frame(frame0, frame1, flow_iters[-1], flow_iters_backwd[-1], t=3/4)
   print(i,"frame")
   visualize_int_frames(it_f1,it_f2, it_f3,i,out_path)

!apt-get install ffmpeg

!ffmpeg -framerate 30 -i /content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/HS_flower/image%03d.png -c:v libx264 -pix_fmt yuv420p flower_video_HS.mp4

!ffmpeg -framerate 30 -i /content/drive/MyDrive/fern_and_flower_llff/fern_and_flower_llff/HS_fern/image%03d.png -c:v libx264 -pix_fmt yuv420p fern_video_HS.mp4